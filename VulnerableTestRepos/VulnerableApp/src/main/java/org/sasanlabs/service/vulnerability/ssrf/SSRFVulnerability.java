package org.sasanlabs.service.vulnerability.ssrf;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLConnection;
import java.util.stream.Collectors;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * This class contains vulnerabilities related to SSRF.
 *
 * @author GitHub : gled02
 */
@VulnerableAppRestController(descriptionLabel = "SSRF_VULNERABILITY", value = "SSRFVulnerability")
public class SSRFVulnerability {

    private static final String FILE_URL = "fileurl";
    private static final String FILE_PROTOCOL = "file://";
    private final String gistUrl;

    public SSRFVulnerability(@Value("${gistId.sasanlabs.projects}") String gistId) {
        gistUrl = "https://gist.githubusercontent.com/raw/" + gistId;
    }

    private static final transient Logger LOGGER = LogManager.getLogger(SSRFVulnerability.class);

    private boolean isUrlValid(String url) {
        try {
            URL obj = new URL(url);
            obj.toURI();
            return true;
        } catch (MalformedURLException | URISyntaxException e) {
            LOGGER.error("Provided URL: {} is not valid and following exception occured", url, e);
            return false;
        }
    }

    private ResponseEntity<GenericVulnerabilityResponseBean<String>> invalidUrlResponse() {
        return new ResponseEntity<>(
                new GenericVulnerabilityResponseBean<>("Provided URL not valid", false),
                HttpStatus.OK);
    }

    private ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getGenericVulnerabilityResponseWhenURL(@RequestParam(FILE_URL) String url)
                    throws IOException {
        if (isUrlValid(url)) {
            URL u = new URL(url);
            if (MetaDataServiceMock.isPresent(u)) {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(
                                MetaDataServiceMock.getResponse(u), true),
                        HttpStatus.OK);
            } else {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(
                                getResponseForURLConnection(u), true),
                        HttpStatus.OK);
            }
        } else {
            return invalidUrlResponse();
        }
    }

    String getResponseForURLConnection(URL u) throws IOException {
        URLConnection urlConnection = u.openConnection();
        try (BufferedReader reader =
                new BufferedReader(new InputStreamReader(urlConnection.getInputStream()))) {
            return reader.lines().collect(Collectors.joining());
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "SSRF_VULNERABILITY_URL_WITHOUT_CHECK",
            payload = "SSRF_PAYLOAD_LEVEL_1")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url)) {
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return invalidUrlResponse();
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "SSRF_VULNERABILITY_URL_IF_NOT_FILE_PROTOCOL",
            payload = "SSRF_PAYLOAD_LEVEL_2")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url) && !url.startsWith(FILE_PROTOCOL)) {

            return getGenericVulnerabilityResponseWhenURL(url);

        } else {
            return invalidUrlResponse();
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "SSRF_VULNERABILITY_URL_IF_NOT_FILE_PROTOCOL_AND_169.254.169.254",
            payload = "SSRF_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_3, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url) && !url.startsWith(FILE_PROTOCOL)) {
            if (new URL(url).getHost().equals("169.254.169.254")) {
                return this.invalidUrlResponse();
            }
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return this.invalidUrlResponse();
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "SSRF_VULNERABILITY_URL_IF_NOT_FILE_PROTOCOL_AND_INTERNAL_METADATA_URL",
            payload = "SSRF_PAYLOAD_LEVEL_4")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_4, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url) && !url.startsWith(FILE_PROTOCOL)) {
            if (MetaDataServiceMock.isPresent(new URL(url))) {
                return this.invalidUrlResponse();
            }
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return this.invalidUrlResponse();
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "SSRF_VULNERABILITY_URL_ONLY_IF_IN_THE_WHITELIST")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_1/SSRF",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (gistUrl.equalsIgnoreCase(url)) {
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return this.invalidUrlResponse();
        }
    }
}
