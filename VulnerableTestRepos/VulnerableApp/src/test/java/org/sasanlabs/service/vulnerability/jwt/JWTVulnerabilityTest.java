package org.sasanlabs.service.vulnerability.jwt;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.io.UnsupportedEncodingException;
import java.security.KeyPair;
import java.util.HashMap;
import java.util.Optional;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.impl.JWTValidator;
import org.sasanlabs.service.vulnerability.jwt.impl.LibBasedJWTGenerator;
import org.sasanlabs.service.vulnerability.jwt.keys.JWTAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.springframework.http.*;

/**
 * Tests for {@link JWTVulnerability}
 *
 * @author Joshua Kwiatkowski kw.joshua@mailbox.org
 */
class JWTVulnerabilityTest {
    private static final HashMap<String, String> EMPTY_QUERY = new HashMap<>();

    private static JWTVulnerability jwtVulnerability;
    private static String invalidToken;
    private static String validHighStrengthToken;
    private static String validLowStrengthToken;
    private static String validAsymmetricToken;
    private static String validAsymmetricTokenWithJwk;
    private static HashMap<String, String> fetchQuery;
    private static JWTAlgorithmKMS jwtAlgorithmKmsSpy;
    private static JWTValidator jwtValidator;

    @BeforeAll
    static void setUpAll() throws UnsupportedEncodingException, ServiceApplicationException {
        IJWTTokenGenerator jwtTokenGenerator = new LibBasedJWTGenerator();
        validHighStrengthToken = createSymmetricToken(KeyStrength.HIGH, jwtTokenGenerator);
        invalidToken = validHighStrengthToken + "1";
        validLowStrengthToken = createSymmetricToken(KeyStrength.LOW, jwtTokenGenerator);
        jwtAlgorithmKmsSpy = spy(new JWTAlgorithmKMS());
        validAsymmetricToken = createAsymmetricToken(jwtTokenGenerator, jwtAlgorithmKmsSpy);
        validAsymmetricTokenWithJwk =
                createAsymmetricTokenWithJwk(jwtTokenGenerator, jwtAlgorithmKmsSpy);
        fetchQuery = new HashMap<>();
        fetchQuery.put("fetch", "true");
        jwtValidator = spy(new JWTValidator(jwtTokenGenerator));
        jwtVulnerability =
                new JWTVulnerability(jwtTokenGenerator, jwtValidator, jwtAlgorithmKmsSpy);
    }

    private static String createSymmetricToken(
            KeyStrength keyStrength, IJWTTokenGenerator jwtTokenGenerator)
            throws UnsupportedEncodingException, ServiceApplicationException {
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                new JWTAlgorithmKMS()
                        .getSymmetricAlgorithmKey(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, keyStrength);
        assertTrue(symmetricAlgorithmKey.isPresent(), "SymmetricAlgorithmKey should be present");
        return jwtTokenGenerator.getHMACSignedJWTToken(
                JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
    }

    private static String createAsymmetricToken(
            IJWTTokenGenerator jwtTokenGenerator, JWTAlgorithmKMS jwtAlgorithmKms)
            throws ServiceApplicationException {
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKms.getAsymmetricAlgorithmKey("RS256");
        assertTrue(
                asymmetricAlgorithmKeyPair.isPresent(), "AsymmetricAlgorithmKey should be present");
        return jwtTokenGenerator.getJWTToken_RS256(
                JWTUtils.RS256_TOKEN_TO_BE_SIGNED, asymmetricAlgorithmKeyPair.get().getPrivate());
    }

    private static String createAsymmetricTokenWithJwk(
            IJWTTokenGenerator jwtTokenGenerator, JWTAlgorithmKMS jwtAlgorithmKms)
            throws ServiceApplicationException, UnsupportedEncodingException {
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKms.getAsymmetricAlgorithmKey("RS256");
        assertTrue(
                asymmetricAlgorithmKeyPair.isPresent(), "AsymmetricAlgorithmKey should be present");
        return jwtTokenGenerator.getJWTTokenWithJWKHeader_RS256(
                JWTUtils.GENERIC_BASE64_ENCODED_PAYLOAD, asymmetricAlgorithmKeyPair.get());
    }

    @BeforeEach
    void resetSpies() {
        reset(jwtAlgorithmKmsSpy);
        reset(jwtValidator);
    }

    private static void assertValidOkResponse(
            ResponseEntity<GenericVulnerabilityResponseBean<String>> response) {
        assertEquals(
                HttpStatus.OK.value(),
                response.getStatusCodeValue(),
                "Response code should be 200 - OK");
        assertNotNull(response.getBody(), "Response body should not be null");
        assertTrue(response.getBody().getIsValid(), "Response body should be marked valid");
    }

    private static void assertValidUnauthorizedResponse(
            ResponseEntity<GenericVulnerabilityResponseBean<String>> response) {
        assertEquals(
                HttpStatus.UNAUTHORIZED.value(),
                response.getStatusCodeValue(),
                "Response code should be 401 - Unauthorized");
        assertNotNull(response.getBody(), "Response body should not be null");
        assertFalse(response.getBody().getIsValid(), "Response body should not be marked valid");
    }

    private static void assertTokenInBody(
            ResponseEntity<GenericVulnerabilityResponseBean<String>> response) {
        assertTrue(
                StringUtils.isNotBlank(response.getBody().getContent()),
                "Response body should contain JWT token");
    }

    private static void assertNoTokenInBody(
            ResponseEntity<GenericVulnerabilityResponseBean<String>> response) {
        assertTrue(
                StringUtils.isBlank(response.getBody().getContent()),
                "Response body should NOT contain JWT token");
    }

    private void assertTokenInCookie(
            ResponseEntity<GenericVulnerabilityResponseBean<String>> response,
            String expectedToken,
            boolean httpOnlyExpected) {
        HttpHeaders headers = response.getHeaders();
        assertTrue(
                headers.containsKey(HttpHeaders.SET_COOKIE),
                "Response headers should contain a cookie");
        String cookie = headers.getFirst(HttpHeaders.SET_COOKIE);
        assertTrue(
                cookie.contains(JWTVulnerability.JWT_COOKIE_KEY),
                "Cookie should contain the JWT cookie key");
        assertTrue(cookie.contains(expectedToken), "Cookie should contain the JWT token");
        assertSame(
                httpOnlyExpected,
                cookie.contains("httponly"),
                "Cookie should" + (!httpOnlyExpected ? " NOT " : "") + "contain HttpOnly flag");
    }

    private void assertTokenInAuthorizationHeader(
            ResponseEntity<GenericVulnerabilityResponseBean<String>> response,
            String expectedToken) {
        HttpHeaders headers = response.getHeaders();
        assertTrue(
                headers.containsKey(HttpHeaders.AUTHORIZATION),
                "Response should contain Authorization header");
        String authorization = headers.getFirst(HttpHeaders.AUTHORIZATION);
        assertEquals(
                expectedToken, authorization, "Authorization header should contain the JWT token");
    }

    private static void verifySymmetricAlgorithmKeyCreation(KeyStrength keyStrength) {
        verify(jwtAlgorithmKmsSpy, times(1))
                .getSymmetricAlgorithmKey(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, keyStrength);
    }

    @Test
    @DisplayName("Level 1 - Test that a token is generated if none is submitted")
    void testLevel1Creation() throws Exception {
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure(new HashMap<>());
        assertValidOkResponse(response);
        assertNotNull(response.getBody(), "Response body should not be null");
        assertTokenInBody(response);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.HIGH);
    }

    @Test
    @DisplayName("Level 1 - Test that a valid token is validated successfully")
    void testLevel1SuccessfulValidation() throws Exception {
        HashMap<String, String> query = new HashMap<>();
        query.put(JWTVulnerability.JWT, validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure(query);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
    }

    @Test
    @DisplayName("Level 1 - Test that an invalid token is not validated successfully")
    void testLevel1FailedValidation() throws Exception {
        HashMap<String, String> query = new HashMap<>();
        query.put(JWTVulnerability.JWT, invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure(query);
        assertValidUnauthorizedResponse(response);
        assertEquals(
                response.getBody().getContent(),
                invalidToken,
                "Response body should contain submitted JWT token");
    }

    private static RequestEntity<Void> getCookieTokenRequest(String token) {
        return RequestEntity.get("/")
                .header("cookie", JWTVulnerability.JWT_COOKIE_KEY + token)
                .build();
    }

    @Test
    @DisplayName("Level 2 - Test that a valid token cookie is validated successfully")
    void testLevel2SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure2CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.HIGH);
    }

    @Test
    @DisplayName("Level 2 - Test that an invalid token cookie is not validated successfully")
    void testLevel2FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure2CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
    }

    @Test
    @DisplayName("Level 2 - Test that a token cookie is generated with fetch")
    void testLevel2FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure2CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), false);
    }

    @Test
    @DisplayName("Level 3 - Test that a valid token cookie is validated successfully")
    void testLevel3SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure3CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validHighStrengthToken, true);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.HIGH);
    }

    @Test
    @DisplayName("Level 3 - Test that an invalid token cookie is not validated successfully")
    void testLevel3FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure3CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
    }

    @Test
    @DisplayName("Level 3 - Test that a token cookie is generated with fetch")
    void testLevel3FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure3CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
    }

    @Test
    @DisplayName("Level 4 - Test that a valid token cookie is validated successfully")
    void testLevel4SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validLowStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure4CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validLowStrengthToken, true);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.LOW);
    }

    @Test
    @DisplayName("Level 4 - Test that an invalid token cookie is not validated successfully")
    void testLevel4FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure4CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.LOW);
    }

    @Test
    @DisplayName("Level 4 - Test that a token cookie is generated with fetch")
    void testLevel4FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure4CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.LOW);
    }

    @Test
    @DisplayName("Level 5 - Test that a valid token cookie is validated successfully")
    void testLevel5SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure5CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validHighStrengthToken, true);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.HIGH);
        verify(jwtValidator, times(1))
                .customHMACNullByteVulnerableValidator(
                        eq(validHighStrengthToken), any(), eq(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM));
    }

    @Test
    @DisplayName("Level 5 - Test that an invalid token cookie is not validated successfully")
    void testLevel5FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure5CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
        verify(jwtValidator, times(1))
                .customHMACNullByteVulnerableValidator(
                        eq(invalidToken), any(), eq(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM));
    }

    @Test
    @DisplayName("Level 5 - Test that a token cookie is generated with fetch")
    void testLevel5FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure5CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
    }

    @Test
    @DisplayName("Level 6 - Test that a valid token cookie is validated successfully")
    void testLevel6SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure6CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validHighStrengthToken, true);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.HIGH);
        verify(jwtValidator, times(1))
                .customHMACNoneAlgorithmVulnerableValidator(
                        eq(validHighStrengthToken), any(), eq(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM));
    }

    @Test
    @DisplayName("Level 6 - Test that an invalid token cookie is not validated successfully")
    void testLevel6FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure6CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
        verify(jwtValidator, times(1))
                .customHMACNoneAlgorithmVulnerableValidator(
                        eq(invalidToken), any(), eq(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM));
    }

    @Test
    @DisplayName("Level 6 - Test that a token cookie is generated with fetch")
    void testLevel6FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure6CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
    }

    private static RequestEntity<Void> getAuthorizationTokenRequest(String token) {
        return RequestEntity.get("/").header(HttpHeaders.AUTHORIZATION, token).build();
    }

    @Test
    @DisplayName("Level 7 - Test that a valid authorization token is validated successfully")
    void testLevel7SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getAuthorizationTokenRequest(validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure7CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInAuthorizationHeader(response, validHighStrengthToken);
        verifySymmetricAlgorithmKeyCreation(KeyStrength.HIGH);
    }

    @Test
    @DisplayName("Level 7 - Test that an invalid authorization token is not validated successfully")
    void testLevel7FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getAuthorizationTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure7CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInAuthorizationHeader(response, invalidToken);
    }

    @Test
    @DisplayName("Level 7 - Test that an authorization token is generated with fetch")
    void testLevel7FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getAuthorizationTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure7CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInAuthorizationHeader(response, response.getBody().getContent());
    }

    @Test
    @DisplayName("Level 8 - Test that a valid token cookie is validated successfully")
    void testLevel8SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validAsymmetricToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure8CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validAsymmetricToken, true);
        verify(jwtValidator, times(1))
                .confusionAlgorithmVulnerableValidator(eq(validAsymmetricToken), any());
    }

    @Test
    @DisplayName("Level 8 - Test that an invalid token cookie is not validated successfully")
    void testLevel8FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure8CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
        verify(jwtValidator, times(1))
                .confusionAlgorithmVulnerableValidator(eq(invalidToken), any());
    }

    @Test
    @DisplayName("Level 8 - Test that a token cookie is generated with fetch")
    void testLevel8FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure8CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
    }

    @Test
    @DisplayName("Level 9 - Test that a valid token cookie is validated successfully")
    void testLevel9SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validAsymmetricTokenWithJwk);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure9CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validAsymmetricTokenWithJwk, true);
        verify(jwtValidator, times(1))
                .jwkKeyHeaderPublicKeyTrustingVulnerableValidator(validAsymmetricTokenWithJwk);
    }

    @Test
    @DisplayName("Level 9 - Test that an invalid token cookie is not validated successfully")
    void testLevel9FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure9CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
        verify(jwtValidator, times(1))
                .jwkKeyHeaderPublicKeyTrustingVulnerableValidator(invalidToken);
    }

    @Test
    @DisplayName("Level 9 - Test that a token cookie is generated with fetch")
    void testLevel9FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure9CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
    }

    @Test
    @DisplayName("Level 10 - Test that a valid token cookie is validated successfully")
    void testLevel10SuccessfulValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(validHighStrengthToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure10CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidOkResponse(response);
        assertNoTokenInBody(response);
        assertTokenInCookie(response, validHighStrengthToken, true);
        verify(jwtValidator, times(1))
                .customHMACEmptyTokenVulnerableValidator(
                        eq(validHighStrengthToken), any(), eq(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM));
    }

    @Test
    @DisplayName("Level 10 - Test that an invalid token cookie is not validated successfully")
    void testLevel10FailedValidation() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure10CookieBased(
                        requestEntity, EMPTY_QUERY);
        assertValidUnauthorizedResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, invalidToken, true);
        verify(jwtValidator, times(1))
                .customHMACEmptyTokenVulnerableValidator(
                        eq(invalidToken), any(), eq(JWTUtils.JWT_HMAC_SHA_256_ALGORITHM));
    }

    @Test
    @DisplayName("Level 10 - Test that a token cookie is generated with fetch")
    void testLevel10FetchCookieGeneration() throws Exception {
        RequestEntity<Void> requestEntity = getCookieTokenRequest(invalidToken);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                jwtVulnerability.getVulnerablePayloadLevelUnsecure10CookieBased(
                        requestEntity, fetchQuery);
        assertValidOkResponse(response);
        assertTokenInBody(response);
        assertTokenInCookie(response, response.getBody().getContent(), true);
    }
}
